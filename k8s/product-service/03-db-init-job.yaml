---
# ConfigMap with initialization SQL scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: db-init-scripts
  namespace: product-service
data:
  01-schema.sql: |
    -- Create tables
    CREATE TABLE IF NOT EXISTS products (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        price DECIMAL(10, 2) NOT NULL,
        stock_quantity INTEGER DEFAULT 0,
        category VARCHAR(100),
        sku VARCHAR(100) UNIQUE NOT NULL,
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS categories (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL UNIQUE,
        description TEXT,
        parent_id INTEGER REFERENCES categories(id),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS product_images (
        id SERIAL PRIMARY KEY,
        product_id INTEGER REFERENCES products(id) ON DELETE CASCADE,
        image_url VARCHAR(500) NOT NULL,
        is_primary BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Create indexes
    CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
    CREATE INDEX IF NOT EXISTS idx_products_sku ON products(sku);
    CREATE INDEX IF NOT EXISTS idx_products_active ON products(is_active);
    CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON product_images(product_id);

    -- Create update timestamp trigger
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = CURRENT_TIMESTAMP;
        RETURN NEW;
    END;
    $$ language 'plpgsql';

    CREATE TRIGGER update_products_updated_at BEFORE UPDATE ON products
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

  02-seed-data.sql: |
    -- Insert sample categories
    INSERT INTO categories (name, description) VALUES
        ('Electronics', 'Electronic devices and accessories'),
        ('Clothing', 'Apparel and fashion items'),
        ('Books', 'Books and publications'),
        ('Home & Garden', 'Home improvement and garden supplies')
    ON CONFLICT (name) DO NOTHING;

    -- Insert sample products
    INSERT INTO products (name, description, price, stock_quantity, category, sku) VALUES
        ('Laptop Pro 15', 'High-performance laptop with 15-inch display', 1299.99, 50, 'Electronics', 'LAPTOP-PRO-15'),
        ('Wireless Mouse', 'Ergonomic wireless mouse with precision tracking', 29.99, 200, 'Electronics', 'MOUSE-WIRELESS-01'),
        ('Cotton T-Shirt', 'Comfortable 100% cotton t-shirt', 19.99, 500, 'Clothing', 'TSHIRT-COTTON-M'),
        ('Programming Book', 'Learn advanced programming techniques', 49.99, 100, 'Books', 'BOOK-PROG-ADV-01')
    ON CONFLICT (sku) DO NOTHING;

  03-users-auth.sql: |
    -- Create users and authentication tables (if needed)
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(100) NOT NULL UNIQUE,
        email VARCHAR(255) NOT NULL UNIQUE,
        password_hash VARCHAR(255) NOT NULL,
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        is_active BOOLEAN DEFAULT true,
        is_admin BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_login TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);

---
# Database Migration Job
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration-job
  namespace: product-service
  labels:
    app: product-service
    component: db-migration
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app: product-service
        component: db-migration
    spec:
      restartPolicy: Never
      initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            until pg_isready -h postgres-service -p 5432 -U $(POSTGRES_USER); do
              echo "Waiting for PostgreSQL to be ready..."
              sleep 2
            done
            echo "PostgreSQL is ready!"
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_USER
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
      containers:
      - name: db-migration
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            echo "Starting database migration..."
            
            # Run all SQL scripts in order
            for script in /docker-entrypoint-initdb.d/*.sql; do
              echo "Executing $script..."
              psql -v ON_ERROR_STOP=1 --host=postgres-service --username="$POSTGRES_USER" --dbname="$POSTGRES_DB" < "$script"
              if [ $? -eq 0 ]; then
                echo "✅ Successfully executed $script"
              else
                echo "❌ Failed to execute $script"
                exit 1
              fi
            done
            
            echo "Database migration completed successfully!"
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_DB
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        volumeMounts:
        - name: init-scripts
          mountPath: /docker-entrypoint-initdb.d
          readOnly: true
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
      volumes:
      - name: init-scripts
        configMap:
          name: db-init-scripts
---
# Database Backup CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup
  namespace: product-service
spec:
  schedule: "0 2 * * *"  # Run daily at 2 AM
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: postgres-backup
        spec:
          restartPolicy: OnFailure
          containers:
          - name: backup
            image: postgres:15-alpine
            command:
              - sh
              - -c
              - |
                BACKUP_FILE="/backups/backup-$(date +%Y%m%d-%H%M%S).sql.gz"
                echo "Creating backup: $BACKUP_FILE"
                
                pg_dump -h postgres-service -U "$POSTGRES_USER" "$POSTGRES_DB" | gzip > "$BACKUP_FILE"
                
                if [ $? -eq 0 ]; then
                  echo "✅ Backup completed successfully: $BACKUP_FILE"
                  
                  # Keep only last 7 backups
                  cd /backups
                  ls -t backup-*.sql.gz | tail -n +8 | xargs -r rm
                  echo "Old backups cleaned up"
                else
                  echo "❌ Backup failed"
                  exit 1
                fi
            env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_USER
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_PASSWORD
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_DB
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_PASSWORD
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: postgres-backup-pvc
---
# PVC for backups
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-backup-pvc
  namespace: product-service
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
  storageClassName: standard